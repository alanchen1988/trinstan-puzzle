    ////  PuzzleGameImageView.m//  Puzzle////  Created by Trinstan on 12/4/12.//  Copyright 2012 __MyCompanyName__. All rights reserved.//#import "PuzzleGameImageView.h"#import "UIImage+Category.h"@implementation PuzzleGameImageView@synthesize previousRotation;@synthesize selected;@synthesize grid_x, grid_y;#pragma mark - Initialization-(id)init{return nil;}-(id)initWithFrame:(CGRect)frame{    if (self = [super initWithFrame:frame])    {        self.userInteractionEnabled = YES;        self.multipleTouchEnabled   = YES;        self.transform = CGAffineTransformMakeRotation(arc4random());        [self adjustToNearestDesiredAngle];        previousRotation = self.transform;        self.selected = NO;    }    return self;}-(id)initByCombining:(id)oneView andOther:(id)twoView withRegularSize:(CGSize)pieceSize;{    PuzzleGameImageView *one = oneView;//[oneView copy]; //should probably copy here!    PuzzleGameImageView *two = twoView;//[twoView copy];    CGAffineTransform incomingTransform = one.transform;    one.transform = CGAffineTransformIdentity;    two.transform = CGAffineTransformIdentity;        CGRect oneframe = CGRectMake(one.grid_x * pieceSize.width, one.grid_y * pieceSize.height, one.frame.size.width, one.frame.size.height);    CGRect twoframe = CGRectMake(two.grid_x * pieceSize.width, two.grid_y * pieceSize.height, two.frame.size.width, two.frame.size.height);        CGPoint onepoint, twopoint;    if (oneframe.origin.x < twoframe.origin.x)    {        onepoint.x = 0;         twopoint.x = twoframe.origin.x - oneframe.origin.x;    }    else    {        onepoint.x = oneframe.origin.x - twoframe.origin.x;         twopoint.x = 0;    }    if (oneframe.origin.y < twoframe.origin.y)    {        onepoint.y = 0;        twopoint.y = twoframe.origin.y - oneframe.origin.y;    }    else    {        onepoint.y = oneframe.origin.y - twoframe.origin.y;         twopoint.y = 0;    }            CGRect frame;    frame.origin      = CGPointZero;    frame.size.width  = MAX(onepoint.x + oneframe.size.width, twopoint.x + twoframe.size.width);    frame.size.height = MAX(onepoint.y + oneframe.size.height,twopoint.y + twoframe.size.height);        if (self = [self initWithFrame:frame])    {        UIGraphicsPushContext(UIGraphicsGetCurrentContext());        UIGraphicsBeginImageContext(frame.size);                [one.image drawAtPoint:onepoint];        [two.image drawAtPoint:twopoint];        self.image = UIGraphicsGetImageFromCurrentImageContext();                UIGraphicsEndImageContext();        UIGraphicsPopContext();                NSLog(@"one:(%d,%d), two:(%d,%d)", one.grid_x, one.grid_y, two.grid_x, two.grid_y);        NSLog(@"%@, %@", NSStringFromCGPoint(onepoint), NSStringFromCGPoint(twopoint));        NSLog(@"%@, %@, %@", NSStringFromCGRect(oneframe), NSStringFromCGRect(twoframe), NSStringFromCGRect(frame));		         self.grid_x = MIN(one.grid_x, two.grid_x);        self.grid_y = MIN(one.grid_y, two.grid_y);                self.center = one.center;        self.transform = CGAffineTransformScale(incomingTransform, 0.5, 0.5);        self.previousRotation = self.transform;            }        //[one release]; //should release here after copy!    //[two release];    return self;}#pragma mark - Miscellaneous-(void)setDelegate:(id<PuzzleGestureDelegate, UIGestureRecognizerDelegate>)delegate{    UIPanGestureRecognizer *panner = [[UIPanGestureRecognizer alloc] initWithTarget:delegate action:@selector(panToMatchGesture:)];    [panner setDelegate:delegate];    [self addGestureRecognizer:panner];    [panner release];        UIRotationGestureRecognizer *rotater = [[UIRotationGestureRecognizer alloc] initWithTarget:delegate action:@selector(rotateToMatchGesture:)];    [rotater setDelegate:delegate];    [self addGestureRecognizer:rotater];    [rotater release];        UITapGestureRecognizer *tapper = [[UITapGestureRecognizer alloc] initWithTarget:delegate action:@selector(tapToMatchGesture:)];    [tapper setDelegate:delegate];    [tapper setNumberOfTapsRequired:1];    [self addGestureRecognizer:tapper];    [tapper release];}//not sure if this works yet.-(id)copyWithZone:(NSZone *)zone{    PuzzleGameImageView *copy = [[PuzzleGameImageView alloc] init];    copy.previousRotation = self.previousRotation;    copy.selected = self.selected;    copy.grid_x = self.grid_x;    copy.grid_y = self.grid_y;    return copy;}//this doesn't really work.//http://stackoverflow.com/questions/6073259/getting-rgb-pixel-data-from-cgimage-(BOOL)touchExistsOnTransparency:(CGPoint)touch{    const CGImageRef cgimage = self.image.CGImage;    const size_t width  = CGImageGetWidth(cgimage);    const size_t height = CGImageGetHeight(cgimage);    const size_t bpr    = CGImageGetBytesPerRow(cgimage);    const size_t bpp    = CGImageGetBitsPerPixel(cgimage);    const size_t bpc    = CGImageGetBitsPerComponent(cgimage);    const size_t bytes_per_pixel = bpp / bpc;        const NSData* data = (NSData*)CGDataProviderCopyData(CGImageGetDataProvider(cgimage));    const uint8_t* bytes = [data bytes];        //printf("Pixel Data:\n");    for(size_t row = 0; row < height; row++)    {        for(size_t col = 0; col < width; col++)        {            const uint8_t* pixel = &bytes[row * bpr + col * bytes_per_pixel];                        if (pixel[bytes_per_pixel - 1] == 0x00)                return YES;                        for(size_t x = 0; x < bytes_per_pixel; x++)            {                //printf("%.2X", pixel[x]);                //if( x < bytes_per_pixel - 1 )                //    printf(",");                                            }                    }    }    [data release];    return NO;}-(CGFloat)adjustToNearestDesiredAngle;{    static const CGFloat DESIRED_ANGLE = 3.14159 / 4.0;    const CGFloat angle = atan2(self.transform.b, self.transform.a);    const CGFloat thefloat = (NSInteger)round(angle / DESIRED_ANGLE);    return thefloat * DESIRED_ANGLE;}@end