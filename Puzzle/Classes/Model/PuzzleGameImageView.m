    ////  PuzzleGameImageView.m//  Puzzle////  Created by Trinstan on 12/4/12.//  Copyright 2012 __MyCompanyName__. All rights reserved.//#import "PuzzleGameImageView.h"#import "UIImage+Category.h"#import "Grid.h"@interface PuzzleGameImageView()@property (nonatomic) float padding;@end@implementation PuzzleGameImageView@synthesize previousRotation;@synthesize selected;@synthesize grid_x, grid_y;//@synthesize locations = _locations;@synthesize padding;//@synthesize edges = _edges;//@synthesize image;#pragma mark - Initialization-(id)init{    return nil;}-(id)initWithFrame:(CGRect)frame{    if (self = [super initWithFrame:frame])    {        self.userInteractionEnabled = YES;        self.multipleTouchEnabled   = YES;        //self.transform = CGAffineTransformMakeRotation(arc4random());        [self adjustToNearestDesiredAngle];        previousRotation = self.transform;        self.selected = NO;//        _locations = [[NSMutableArray alloc] initWithCapacity:20];//        _edges = [[NSArray alloc] init];    }    return self;}- (void)dealloc{    [super dealloc];}-(id)initByCombining:(id)oneView andOther:(id)twoView withRegularSize:(CGSize)pieceSize;{    PuzzleGameImageView *one = oneView;//[oneView copy]; //should probably copy here!    PuzzleGameImageView *two = twoView;//[twoView copy];            CGAffineTransform incomingTransform = one.transform;    one.transform = CGAffineTransformIdentity;    two.transform = CGAffineTransformIdentity;        CGRect oneframe = CGRectMake(one.grid_x * pieceSize.width, one.grid_y * pieceSize.height, one.frame.size.width, one.frame.size.height);    CGRect twoframe = CGRectMake(two.grid_x * pieceSize.width, two.grid_y * pieceSize.height, two.frame.size.width, two.frame.size.height);        CGPoint onepoint, twopoint;    if (oneframe.origin.x < twoframe.origin.x)    {        onepoint.x = 0;         twopoint.x = twoframe.origin.x - oneframe.origin.x;    }    else    {        onepoint.x = oneframe.origin.x - twoframe.origin.x;         twopoint.x = 0;    }    if (oneframe.origin.y < twoframe.origin.y)    {        onepoint.y = 0;        twopoint.y = twoframe.origin.y - oneframe.origin.y;    }    else    {        onepoint.y = oneframe.origin.y - twoframe.origin.y;         twopoint.y = 0;    }            CGRect frame;    frame.origin      = CGPointZero;    frame.size.width  = MAX(onepoint.x + oneframe.size.width, twopoint.x + twoframe.size.width);    frame.size.height = MAX(onepoint.y + oneframe.size.height,twopoint.y + twoframe.size.height);        if (self = [self initWithFrame:frame])    {        UIGraphicsPushContext(UIGraphicsGetCurrentContext());        UIGraphicsBeginImageContext(frame.size);                [one.image drawAtPoint:onepoint];        [two.image drawAtPoint:twopoint];        self.image = UIGraphicsGetImageFromCurrentImageContext();                UIGraphicsEndImageContext();        UIGraphicsPopContext();                //for locationsArray//        if (_locations == nil) {//            _locations = [[NSMutableArray alloc] initWithCapacity:20];//        }                //[self.locations addObjectsFromArray:one.locations];        //[self.locations addObjectsFromArray:two.locations];		         self.grid_x = MIN(one.grid_x, two.grid_x);        self.grid_y = MIN(one.grid_y, two.grid_y);                self.center = one.center;        self.transform = CGAffineTransformScale(incomingTransform, 0.5, 0.5);        self.previousRotation = self.transform;    }        //[one release]; //should release here after copy!    //[two release];    return self;}#pragma mark - Miscellaneous-(void)setDelegate:(id<PuzzleGestureDelegate, UIGestureRecognizerDelegate>)delegate{    UIPanGestureRecognizer *panner = [[UIPanGestureRecognizer alloc] initWithTarget:delegate action:@selector(panToMatchGesture:)];    [panner setDelegate:delegate];    [self addGestureRecognizer:panner];    [panner release];        UIRotationGestureRecognizer *rotater = [[UIRotationGestureRecognizer alloc] initWithTarget:delegate action:@selector(rotateToMatchGesture:)];    [rotater setDelegate:delegate];    [self addGestureRecognizer:rotater];    [rotater release];        UITapGestureRecognizer *tapper = [[UITapGestureRecognizer alloc] initWithTarget:delegate action:@selector(tapToMatchGesture:)];    [tapper setDelegate:delegate];    [tapper setNumberOfTapsRequired:2];    [self addGestureRecognizer:tapper];    [tapper release];}-(id)copyWithZone:(NSZone *)zone{    PuzzleGameImageView *copy = [[PuzzleGameImageView alloc] init];    copy.previousRotation = self.previousRotation;    copy.selected = self.selected;    copy.grid_x = self.grid_x;    copy.grid_y = self.grid_y;    return copy;}-(CGFloat)adjustToNearestDesiredAngle;{    static const CGFloat DESIRED_ANGLE = 3.14159 / 4.0;    const CGFloat angle = atan2(self.transform.b, self.transform.a);    const CGFloat thefloat = (NSInteger)round(angle / DESIRED_ANGLE);    return thefloat * DESIRED_ANGLE;}#pragma mark -#pragma mark Draw#define CO_PADDING 0/*- (CGPoint)sum:(CGPoint)a plus:(CGPoint)b firstWeight:(float)f{    return CGPointMake(f*a.x+(1-f)*b.x, f*a.y+(1-f)*b.y);}- (CGPoint)sum:(CGPoint)a plus:(CGPoint)b{    return CGPointMake(a.x+b.x, a.y+b.y);}- (void)drawEdgeNumber:(int)n ofType:(int)type inContext:(CGContextRef)ctx {        float x = self.bounds.size.width;    float y = self.bounds.size.height;    float l;    float p = self.padding;        BOOL vertical = NO;    int sign = 1;        CGPoint a = CGPointZero;    CGPoint b = CGPointZero;        switch (n) {        case 1:            a = CGPointMake(p, p);            b = CGPointMake(x-p, p);            vertical = YES;            sign = -1;            break;        case 2:            a = CGPointMake(x-p, p);            b = CGPointMake(x-p, y-p);            sign = 1;            break;        case 3:            a = CGPointMake(x-p, y-p);            b = CGPointMake(p, y-p);            vertical = YES;            sign = 1;            break;        case 4:            a = CGPointMake(p, y-p);            b = CGPointMake(p, p);            sign = -1;            break;                    default:            break;    }        if (type<0) {        sign *= -1;    }        if (vertical) {        l = y;    } else {        l = x;    }        float l3 = (l-2*p)/3;        CGPoint point = [self sum:a plus:b firstWeight:2.0/3.0];    CGContextAddLineToPoint(ctx, point.x, point.y);        if (abs(type)==1) { //Triangolino                CGPoint p2 = [self sum:a plus:b firstWeight:1.0/2.0];                if (!vertical) {            p2 = [self sum:p2 plus:CGPointMake(sign*(p-CO_PADDING), 0)];        } else {            p2 = [self sum:p2 plus:CGPointMake(0, sign*(p-CO_PADDING))];        }                CGContextAddLineToPoint(ctx, p2.x, p2.y);                        CGPoint p3 = [self sum:a plus:b firstWeight:1.0/3.0];        CGContextAddLineToPoint(ctx, p3.x, p3.y);            } else if (abs(type)==2) { //Cerchietto                CGPoint p2 = [self sum:a plus:b firstWeight:1.0/2.0];                switch (n) {            case 1:                CGContextAddArc(ctx, p2.x, p2.y, (l-2*p)/6, M_PI, 0, sign+1);                break;            case 2:                CGContextAddArc(ctx, p2.x, p2.y, (l-2*p)/6, M_PI*3/2, M_PI/2, sign-1);                break;            case 3:                CGContextAddArc(ctx, p2.x, p2.y, (l-2*p)/6, 0, M_PI, sign-1);                break;            case 4:                CGContextAddArc(ctx, p2.x, p2.y, (l-2*p)/6, M_PI/2, M_PI*3/2, sign+1);                break;            default:                break;        }            } else if (abs(type)==3) { //Quadratino                CGPoint p2 = point;        CGPoint p3 = point;        CGPoint p4 = point;                switch (n) {            case 1:                p2 = [self sum:p2 plus:CGPointMake(0, sign*(p-CO_PADDING))];                p3 = [self sum:p2 plus:CGPointMake(l3, 0)];                p4 = [self sum:point plus:CGPointMake(l3, 0)];                break;            case 2:                p2 = [self sum:p2 plus:CGPointMake(sign*(p-CO_PADDING), 0)];                p3 = [self sum:p2 plus:CGPointMake(0, l3)];                p4 = [self sum:point plus:CGPointMake(0 , l3)];                break;            case 3:                p2 = [self sum:p2 plus:CGPointMake(0, sign*(p-CO_PADDING))];                p3 = [self sum:p2 plus:CGPointMake(-l3, 0)];                p4 = [self sum:point plus:CGPointMake(-l3, 0)];                break;            case 4:                p2 = [self sum:p2 plus:CGPointMake(sign*(p-CO_PADDING), 0)];                p3 = [self sum:p2 plus:CGPointMake(0, -l3)];                p4 = [self sum:point plus:CGPointMake(0 , -l3)];                break;            default:                break;        }                CGContextAddLineToPoint(ctx, p2.x, p2.y);        CGContextAddLineToPoint(ctx, p3.x, p3.y);        CGContextAddLineToPoint(ctx, p4.x, p4.y);                            } else {                point = [self sum:a plus:b firstWeight:1.0/3.0];        CGContextAddLineToPoint(ctx, point.x, point.y);            }        CGContextAddLineToPoint(ctx, b.x, b.y);                //UIGraphicsPopContext();    }- (void)drawRect:(CGRect)rect {        //return;    padding = self.bounds.size.width*0.15;    //float LINE_WIDTH = self.bounds.size.width*0.005;        CGContextRef ctx = UIGraphicsGetCurrentContext();                CGContextSetRGBStrokeColor(ctx, 0, 0, 0, 0.1);    //CGContextSetLineWidth(ctx, LINE_WIDTH);    CGContextSetLineJoin(ctx, kCGLineJoinRound);            CGContextBeginPath(ctx);    CGContextMoveToPoint(ctx, self.padding, self.padding);        if (self.edges.count > 0) {        for (int i=1; i<5; i++) {            int e = [[self.edges objectAtIndex:i-1] intValue];            [self drawEdgeNumber:i ofType:e inContext:ctx];        }    }            CGContextClip(ctx);    [image drawInRect:CGRectMake(0, 0, self.bounds.size.width, self.bounds.size.height)];            CGContextBeginPath(ctx);    CGContextMoveToPoint(ctx, self.padding, self.padding);        if (self.edges.count > 0) {    for (int i=1; i<5; i++) {        int e = [[self.edges objectAtIndex:i-1] intValue];        [self drawEdgeNumber:i ofType:e inContext:ctx];    }}    CGContextClosePath(ctx);    CGContextDrawPath(ctx, kCGPathStroke);    }*/@end