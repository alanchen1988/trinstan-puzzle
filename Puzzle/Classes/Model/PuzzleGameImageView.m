    ////  PuzzleGameImageView.m//  Puzzle////  Created by Trinstan on 12/4/12.//  Copyright 2012 __MyCompanyName__. All rights reserved.//#import "PuzzleGameImageView.h"#import "UIImage+Category.h"#import "Grid.h"@implementation PuzzleGameImageView@synthesize previousRotation;@synthesize selected;@synthesize grid_x, grid_y;@synthesize locations = _locations;#pragma mark - Initialization-(id)init{return nil;}-(id)initWithFrame:(CGRect)frame{    if (self = [super initWithFrame:frame])    {        self.userInteractionEnabled = YES;        self.multipleTouchEnabled   = YES;        self.transform = CGAffineTransformMakeRotation(arc4random());        [self adjustToNearestDesiredAngle];        previousRotation = self.transform;        self.selected = NO;        _locations = [[NSMutableArray alloc] initWithCapacity:20];    }    return self;}- (void)dealloc{    [_locations release];    _locations = nil;    [super dealloc];}-(id)initByCombining:(id)oneView andOther:(id)twoView withRegularSize:(CGSize)pieceSize;{    PuzzleGameImageView *one = oneView;//[oneView copy]; //should probably copy here!    PuzzleGameImageView *two = twoView;//[twoView copy];            CGAffineTransform incomingTransform = one.transform;    one.transform = CGAffineTransformIdentity;    two.transform = CGAffineTransformIdentity;        CGRect oneframe = CGRectMake(one.grid_x * pieceSize.width, one.grid_y * pieceSize.height, one.frame.size.width, one.frame.size.height);    CGRect twoframe = CGRectMake(two.grid_x * pieceSize.width, two.grid_y * pieceSize.height, two.frame.size.width, two.frame.size.height);        CGPoint onepoint, twopoint;    if (oneframe.origin.x < twoframe.origin.x)    {        onepoint.x = 0;         twopoint.x = twoframe.origin.x - oneframe.origin.x;    }    else    {        onepoint.x = oneframe.origin.x - twoframe.origin.x;         twopoint.x = 0;    }    if (oneframe.origin.y < twoframe.origin.y)    {        onepoint.y = 0;        twopoint.y = twoframe.origin.y - oneframe.origin.y;    }    else    {        onepoint.y = oneframe.origin.y - twoframe.origin.y;         twopoint.y = 0;    }            CGRect frame;    frame.origin      = CGPointZero;    frame.size.width  = MAX(onepoint.x + oneframe.size.width, twopoint.x + twoframe.size.width);    frame.size.height = MAX(onepoint.y + oneframe.size.height,twopoint.y + twoframe.size.height);        if (self = [self initWithFrame:frame])    {        UIGraphicsPushContext(UIGraphicsGetCurrentContext());        UIGraphicsBeginImageContext(frame.size);                [one.image drawAtPoint:onepoint];        [two.image drawAtPoint:twopoint];        self.image = UIGraphicsGetImageFromCurrentImageContext();                UIGraphicsEndImageContext();        UIGraphicsPopContext();                //for locationsArray        if (_locations == nil) {            _locations = [[NSMutableArray alloc] initWithCapacity:20];        }                [self.locations addObjectsFromArray:one.locations];        [self.locations addObjectsFromArray:two.locations];		         self.grid_x = MIN(one.grid_x, two.grid_x);        self.grid_y = MIN(one.grid_y, two.grid_y);        //        NSLog(@"one:(%d,%d), two:(%d,%d), self:(%d, %d)", one.grid_x, one.grid_y, two.grid_x, two.grid_y, self.grid_x, self.grid_y);//        NSLog(@"%@, %@", NSStringFromCGPoint(onepoint), NSStringFromCGPoint(twopoint));//        NSLog(@"%@, %@, %@", NSStringFromCGRect(oneframe), NSStringFromCGRect(twoframe), NSStringFromCGRect(frame));//        NSLog(@"one location = %@, two location = %@ï¼Œ self location = %@", one.locations, two.locations, self.locations);                self.center = one.center;        self.transform = CGAffineTransformScale(incomingTransform, 1.0, 1.0);        self.previousRotation = self.transform;            }        //[one release]; //should release here after copy!    //[two release];    return self;}#pragma mark - Miscellaneous-(void)setDelegate:(id<PuzzleGestureDelegate, UIGestureRecognizerDelegate>)delegate{    UIPanGestureRecognizer *panner = [[UIPanGestureRecognizer alloc] initWithTarget:delegate action:@selector(panToMatchGesture:)];    [panner setDelegate:delegate];    [self addGestureRecognizer:panner];    [panner release];        UIRotationGestureRecognizer *rotater = [[UIRotationGestureRecognizer alloc] initWithTarget:delegate action:@selector(rotateToMatchGesture:)];    [rotater setDelegate:delegate];    [self addGestureRecognizer:rotater];    [rotater release];        UITapGestureRecognizer *tapper = [[UITapGestureRecognizer alloc] initWithTarget:delegate action:@selector(tapToMatchGesture:)];    [tapper setDelegate:delegate];    [tapper setNumberOfTapsRequired:2];    [self addGestureRecognizer:tapper];    [tapper release];}-(id)copyWithZone:(NSZone *)zone{    PuzzleGameImageView *copy = [[PuzzleGameImageView alloc] init];    copy.previousRotation = self.previousRotation;    copy.selected = self.selected;    copy.grid_x = self.grid_x;    copy.grid_y = self.grid_y;    return copy;}-(CGFloat)adjustToNearestDesiredAngle;{    static const CGFloat DESIRED_ANGLE = 3.14159 / 4.0;    const CGFloat angle = atan2(self.transform.b, self.transform.a);    const CGFloat thefloat = (NSInteger)round(angle / DESIRED_ANGLE);    return thefloat * DESIRED_ANGLE;}@end