    ////  PuzzleGameImageView.m//  Puzzle////  Created by Trinstan on 12/4/12.//  Copyright 2012 __MyCompanyName__. All rights reserved.//#import "PuzzleGameImageView.h"#import "UIImage+Category.h"#import "Grid.h"@interface PuzzleGameImageView()@end@implementation PuzzleGameImageView@synthesize previousRotation;@synthesize selected;@synthesize grid_x, grid_y;@synthesize isUp, isDown, isLeft, isRight;@synthesize isCombined;@synthesize arrayCount;@synthesize selectedArray;#pragma mark - Initialization-(id)init{    return nil;}-(id)initWithFrame:(CGRect)frame{    if (self = [super initWithFrame:frame])    {        self.userInteractionEnabled = YES;        self.multipleTouchEnabled   = YES;        //self.transform = CGAffineTransformMakeRotation(arc4random());        [self adjustToNearestDesiredAngle];        previousRotation = self.transform;        self.selected = NO;        self.selectedArray = [[NSMutableArray alloc] initWithCapacity:20];//        _locations = [[NSMutableArray alloc] initWithCapacity:20];//        _edges = [[NSArray alloc] init];    }    return self;}- (void)dealloc{    [super dealloc];}#define WIDTH 160#define HEIGHT  150#define TempTap 60- (CGRect)rectForView:(PuzzleGameImageView *)one{    CGRect rect2x = CGRectZero;    int row = one.grid_y+1;    int colunm = one.grid_x+1;        if (row == 1 && colunm == 1) rect2x = CGRectMake(0, 0, WIDTH, HEIGHT);    else if (row == 1 && colunm == 2) rect2x = CGRectMake(110, 0, 140, HEIGHT + 30);    else if (row == 1 && colunm == 3) rect2x = CGRectMake(205, 0, WIDTH + 50, HEIGHT);    else if (row == 1 && colunm == 4) rect2x = CGRectMake(365, 0, 130, WIDTH);    else if (row == 2 && colunm == 1) rect2x = CGRectMake(0, HEIGHT - TempTap, 130, HEIGHT + 40);    else if (row == 2 && colunm == 2) rect2x = CGRectMake(70, 120, WIDTH + TempTap, HEIGHT);    else if (row == 2 && colunm == 3) rect2x = CGRectMake(240, 80, HEIGHT, HEIGHT + TempTap);    else if (row == 2 && colunm == 4) rect2x = CGRectMake(325, 120, WIDTH + TempTap, HEIGHT);    else if (row == 3 && colunm == 1) rect2x = CGRectMake(0, 240, WIDTH, HEIGHT);    else if (row == 3 && colunm == 2) rect2x = CGRectMake(110, 210, 140, 210);    else if (row == 3 && colunm == 3) rect2x = CGRectMake(200, 245, 210, 140);    else if (row == 3 && colunm == 4) rect2x = CGRectMake(357, 205, 200, 140);    else if (row == 4 && colunm == 1) rect2x = CGRectMake(0, 330, 130, 180);    else if (row == 4 && colunm == 2) rect2x = CGRectMake(80, 355, 210, HEIGHT);    else if (row == 4 && colunm == 3) rect2x = CGRectMake(235, 330, 130, 180);    else if (row == 4 && colunm == 4) rect2x = CGRectMake(320, 370, 180, 140);        return rect2x;}- (CGRect)rectForRow:(int)y column:(int)x{    CGRect rect2x = CGRectZero;    int row = y+1;    int colunm = x+1;        if (row == 1 && colunm == 1) rect2x = CGRectMake(0, 0, WIDTH, HEIGHT);    else if (row == 1 && colunm == 2) rect2x = CGRectMake(110, 0, 140, HEIGHT + 30);    else if (row == 1 && colunm == 3) rect2x = CGRectMake(205, 0, WIDTH + 50, HEIGHT);    else if (row == 1 && colunm == 4) rect2x = CGRectMake(365, 0, 130, WIDTH);    else if (row == 2 && colunm == 1) rect2x = CGRectMake(0, HEIGHT - TempTap, 130, HEIGHT + 40);    else if (row == 2 && colunm == 2) rect2x = CGRectMake(70, 120, WIDTH + TempTap, HEIGHT);    else if (row == 2 && colunm == 3) rect2x = CGRectMake(240, 80, HEIGHT, HEIGHT + TempTap);    else if (row == 2 && colunm == 4) rect2x = CGRectMake(325, 120, WIDTH + TempTap, HEIGHT);    else if (row == 3 && colunm == 1) rect2x = CGRectMake(0, 240, WIDTH, HEIGHT);    else if (row == 3 && colunm == 2) rect2x = CGRectMake(110, 210, 140, 210);    else if (row == 3 && colunm == 3) rect2x = CGRectMake(200, 245, 210, 140);    else if (row == 3 && colunm == 4) rect2x = CGRectMake(357, 205, 200, 140);    else if (row == 4 && colunm == 1) rect2x = CGRectMake(0, 330, 130, 180);    else if (row == 4 && colunm == 2) rect2x = CGRectMake(80, 355, 210, HEIGHT);    else if (row == 4 && colunm == 3) rect2x = CGRectMake(235, 330, 130, 180);    else if (row == 4 && colunm == 4) rect2x = CGRectMake(320, 370, 180, 140);        return rect2x;}#define TEMP_NEW    50-(id)initByCombining:(id)oneView andOther:(id)twoView withRegularSize:(CGSize)pieceSize;{    PuzzleGameImageView *one = oneView;//[oneView copy]; //should probably copy here!    PuzzleGameImageView *two = twoView;//[twoView copy];            CGAffineTransform incomingTransform = one.transform;    one.transform = CGAffineTransformIdentity;    two.transform = CGAffineTransformIdentity;        CGRect oneframe = one.frame;    CGRect twoframe = two.frame;        if (one.isCombined)    {        int maxX = INT_MAX;        for (Grid *newGrid in one.selectedArray)        {            if (newGrid.x < maxX) maxX = newGrid.x;        }                int maxY = INT_MAX;        for (Grid *newGrid in one.selectedArray)        {            if (newGrid.y < maxY) maxY = newGrid.y;        }                oneframe = CGRectMake([self rectForRow:maxY column:maxX].origin.x, [self rectForRow:maxY column:maxX].origin.y, one.frame.size.width, one.frame.size.height);    }    else    {        oneframe = CGRectMake([self rectForView:one].origin.x, [self rectForView:one].origin.y, one.frame.size.width, one.frame.size.height);    }            if (two.isCombined)    {        int maxX = INT_MAX;        for (Grid *newGrid in two.selectedArray)        {            if (newGrid.x < maxX) maxX = newGrid.x;        }                int maxY = INT_MAX;        for (Grid *newGrid in two.selectedArray)        {            if (newGrid.y < maxY) maxY = newGrid.y;        }                twoframe = CGRectMake([self rectForRow:maxY column:maxX].origin.x, [self rectForRow:maxY column:maxX].origin.y, two.frame.size.width, two.frame.size.height);    }    else    {        twoframe = CGRectMake([self rectForView:two].origin.x, [self rectForView:two].origin.y, two.frame.size.width, two.frame.size.height);    }        CGPoint onepoint, twopoint;    //for x    if (oneframe.origin.x < twoframe.origin.x)    {        onepoint.x = 0;        twopoint.x = twoframe.origin.x - oneframe.origin.x;    }    else if (oneframe.origin.x > twoframe.origin.x)    {        twopoint.x = 0;        onepoint.x = oneframe.origin.x - twoframe.origin.x;            }    else    {        onepoint.x = 0;        twopoint.x = 0;    }        //for Y    if (oneframe.origin.y < twoframe.origin.y)    {        onepoint.y = 0;        twopoint.y = twoframe.origin.y - oneframe.origin.y;    }    else if (oneframe.origin.y > twoframe.origin.y)    {                twopoint.y = 0;        onepoint.y = oneframe.origin.y - twoframe.origin.y;            }    else    {        onepoint.y = 0;        twopoint.y = 0;    }            CGRect frame;    frame.origin      = CGPointZero;    frame.size.width  = MAX(onepoint.x + oneframe.size.width, twopoint.x + twoframe.size.width);    frame.size.height = MAX(onepoint.y + oneframe.size.height,twopoint.y + twoframe.size.height);        if (self = [self initWithFrame:frame])    {        UIGraphicsPushContext(UIGraphicsGetCurrentContext());        UIGraphicsBeginImageContext(frame.size);                [one.image drawAtPoint:onepoint];        [two.image drawAtPoint:twopoint];        self.image = UIGraphicsGetImageFromCurrentImageContext();                UIGraphicsEndImageContext();        UIGraphicsPopContext();                self.isCombined = YES;                [self.selectedArray removeAllObjects];        for (Grid *oneGrid in one.selectedArray)        {            [self.selectedArray addObject:oneGrid];        }                for (Grid *oneGrid in two.selectedArray)        {            [self.selectedArray addObject:oneGrid];        }                //self.grid_x = MIN(one.grid_x, two.grid_x);        //self.grid_y = MIN(one.grid_y, two.grid_y);                        self.center = one.center;        self.transform = CGAffineTransformScale(incomingTransform, 0.5, 0.5);        self.previousRotation = self.transform;    }        //[one release]; //should release here after copy!    //[two release];    return self;}#pragma mark - Miscellaneous-(void)setDelegate:(id<PuzzleGestureDelegate, UIGestureRecognizerDelegate>)delegate{    UIPanGestureRecognizer *panner = [[UIPanGestureRecognizer alloc] initWithTarget:delegate action:@selector(panToMatchGesture:)];    [panner setDelegate:delegate];    [self addGestureRecognizer:panner];    [panner release];        UIRotationGestureRecognizer *rotater = [[UIRotationGestureRecognizer alloc] initWithTarget:delegate action:@selector(rotateToMatchGesture:)];    [rotater setDelegate:delegate];    [self addGestureRecognizer:rotater];    [rotater release];        UITapGestureRecognizer *tapper = [[UITapGestureRecognizer alloc] initWithTarget:delegate action:@selector(tapToMatchGesture:)];    [tapper setDelegate:delegate];    [tapper setNumberOfTapsRequired:2];    [self addGestureRecognizer:tapper];    [tapper release];}-(id)copyWithZone:(NSZone *)zone{    PuzzleGameImageView *copy = [[PuzzleGameImageView alloc] init];    copy.previousRotation = self.previousRotation;    copy.selected = self.selected;    copy.grid_x = self.grid_x;    copy.grid_y = self.grid_y;    copy.isCombined = self.isCombined;    copy.isDown = self.isDown;    copy.isUp = self.isUp;    copy.isLeft = self.isLeft;    copy.isRight = self.isRight;    return copy;}-(CGFloat)adjustToNearestDesiredAngle{    static const CGFloat DESIRED_ANGLE = 3.14159 / 4.0;    const CGFloat angle = atan2(self.transform.b, self.transform.a);    const CGFloat thefloat = (NSInteger)round(angle / DESIRED_ANGLE);    return thefloat * DESIRED_ANGLE;}- (void)drawRect:(CGRect)rect{    NSLog(@"draw rect");}#pragma mark -#pragma mark Draw#define CO_PADDING 0/*{    if (one.isCombined)    {        int maxX = INT_MAX;        //get the Min x        for (Grid *newGrid in one.selectedArray)        {            if (newGrid.x < maxX) maxX = newGrid.x;        }        //get the y from the Min x        int minY = INT_MAX;        NSMutableArray *minYArray = [[NSMutableArray alloc] initWithCapacity:20];        for (Grid *newGrid in one.selectedArray)        {            if (newGrid.x == maxX)            {                [minYArray addObject:newGrid];            }        }                for (Grid *newGrid in minYArray)        {            if (newGrid.y < minY) minY = newGrid.y;        }                oneframe.origin.x = [self rectForRow:minY column:maxX].origin.x;                        // get the Min Y        int maxY = INT_MAX;        for (Grid *newGrid in one.selectedArray)        {            if (newGrid.y < maxY) maxY = newGrid.y;        }        //get the x from the Min y        int minX = INT_MAX;        NSMutableArray *minXArray = [[NSMutableArray alloc] initWithCapacity:20];        for (Grid *newGrid in one.selectedArray)        {            if (newGrid.y == maxY)            {                [minXArray addObject:newGrid];            }        }                for (Grid *newGrid in minXArray)        {            if (newGrid.x < minX) minX = newGrid.x;        }                oneframe.origin.y = [self rectForRow:maxY column:minX].origin.y;    }    else    {        oneframe = CGRectMake([self rectForView:one].origin.x, [self rectForView:one].origin.y, one.frame.size.width, one.frame.size.height);    }            if (two.isCombined)    {        int maxX = INT_MAX;        //get the Min x        for (Grid *newGrid in two.selectedArray)        {            if (newGrid.x < maxX) maxX = newGrid.x;        }        //get the y from the Min x        int minY = INT_MAX;        NSMutableArray *minYArray = [[NSMutableArray alloc] initWithCapacity:20];        for (Grid *newGrid in two.selectedArray)        {            if (newGrid.x == maxX)            {                [minYArray addObject:newGrid];            }        }                for (Grid *newGrid in minYArray)        {            if (newGrid.y < minY) minY = newGrid.y;        }                twoframe.origin.x = [self rectForRow:minY column:maxX].origin.x;                        //get the Min y        int maxY = INT_MAX;        for (Grid *newGrid in two.selectedArray)        {            if (newGrid.y < maxY) maxY = newGrid.y;        }        //get the x from the Min y        int minX = INT_MAX;        NSMutableArray *minXArray = [[NSMutableArray alloc] initWithCapacity:20];        for (Grid *newGrid in two.selectedArray)        {            if (newGrid.y == maxY)            {                [minXArray addObject:newGrid];            }        }                for (Grid *newGrid in minXArray)        {            if (newGrid.x < minX) minX = newGrid.x;        }                twoframe.origin.y = [self rectForRow:maxY column:minX].origin.y;    }    else    {        twoframe = CGRectMake([self rectForView:two].origin.x, [self rectForView:two].origin.y, two.frame.size.width, two.frame.size.height);    }}*/@end