////  PuzzleGameModel.m//  Puzzle////  Created by Trinstan on 12/4/12.//  Copyright 2012 __MyCompanyName__. All rights reserved.//#import "PuzzleGameModel.h"#import "PuzzleGameImageView.h"#import "Grid.h"#import "Piece.h"#pragma mark - Piece Class#pragma mark - MJGameModel Class@interface PuzzleGameModel()@property (nonatomic, retain) NSMutableArray *gamePieces;//@property (nonatomic, retain) NSMutableArray *otherPieces;-(Piece*)pieceWithReference:(id)reference;-(NSArray*)selectedPieces;-(void)testSelectedPieces;-(void)testSelectedPieces:(Piece *)selectedPiece;@end@implementation PuzzleGameModel@synthesize pieceSize;@synthesize delegate;@synthesize gamePieces = _gamePieces;//@synthesize otherPieces = _otherPieces;-(id)gamePieces{    if (_gamePieces == nil)        _gamePieces = [[NSMutableArray alloc] initWithCapacity:20];    return _gamePieces;}//-(id)otherPieces//{//    if (_otherPieces == nil)//        _otherPieces = [[NSMutableArray alloc] initWithCapacity:20];//    return _otherPieces;//}-(Piece*)pieceWithReference:(id)referenc{    for(Piece *piece in self.gamePieces)        if (referenc == piece.reference)            return piece;    return nil;}-(NSArray*)selectedPieces{    NSMutableArray *array = [NSMutableArray arrayWithCapacity:2];    for(Piece *piece in self.gamePieces)         if (piece.selected)             [array addObject:piece];    return array;}-(void)setGamePiece:(id)obj atGridPosition:(CGPoint)point{    //PuzzleGameImageView *view = (PuzzleGameImageView *)obj;    Piece *piece = [self pieceWithReference:obj];        if (nil == piece) piece = [[[Piece alloc] init] autorelease];        piece.reference = obj;        [self.gamePieces addObject:piece];//    [self.otherPieces addObject:piece];        [piece.gridLocations addObject:[Grid gridWith:point.x                                              and:point.y]];}-(void)setGamePiece:(id)obj atWorldPosition:(CGPoint)worldPosition{    Piece *piece = [self pieceWithReference:obj];	    if (nil == piece)        NSLog(@"Gotta do something about pieces not being in the model.");        [self testSelectedPieces];}-(void)updateWithView:(id)view andSelected:(BOOL)selected{    Piece *piece = [self pieceWithReference:view];    if (nil == piece)    {            }        piece.selected = selected;    //[piece retain];        //[self.otherPieces removeAllObjects];//    self.otherPieces = [NSMutableArray arrayWithArray:self.gamePieces];        //[self testSelectedPieces:piece];    [self testSelectedPieces];    //[piece autorelease];}-(void)combinePieces:(id)one andOther:(id)two intoNew:(id)newView{    Piece *onePiece = [self pieceWithReference:one];    Piece *twoPiece = [self pieceWithReference:two];    Piece *piece = [[Piece alloc] init];    piece.reference = newView;        for (Grid *one in onePiece.gridLocations)        [piece.gridLocations addObject:one];        for (Grid *two in twoPiece.gridLocations)        [piece.gridLocations addObject:two];		    [self.gamePieces removeObject:onePiece];    [self.gamePieces removeObject:twoPiece];    [self.gamePieces addObject:piece];        if (self.gamePieces.count == 1)    {        [self.delegate userDidSolvePuzzle];        [self.gamePieces removeAllObjects];    }}/*-(void)testSelectedPieces:(Piece *)piece{    if (piece == nil) NSLog(@"testSelectedPieces piece is nil");    [self.otherPieces removeObject:piece];        for (Piece *otherPiece in self.otherPieces)    {        for (Grid *otherGrid in otherPiece.gridLocations)        {            for (Grid *pieceGrid in piece.gridLocations)            {                if (ABS(otherGrid.x - pieceGrid.x) == 0 || ABS(otherGrid.y - pieceGrid.y) == 0)                {                    [self.delegate combinePiece:otherPiece.reference withOther:piece.reference];                    break;                }            }        }            }    }*/-(void)testSelectedPieces{    NSArray *selectedPieces = [self selectedPieces];        if (selectedPieces.count < 2) return;        Piece *one = [selectedPieces objectAtIndex:0];    Piece *two = [selectedPieces objectAtIndex:1];    //NSLog(@"one = %@", one.gridLocations);    //NSLog(@"two = %@", two.gridLocations);    for(Grid *oneGrid in one.gridLocations)    {        //NSLog(@"oneGrid x = %d, oneGrid y = %d ", oneGrid.x, oneGrid.y);		for(Grid *twoGrid in two.gridLocations)        {            //NSLog(@"twoGrid x = %d, twoGrid y = %d ", twoGrid.x, twoGrid.y);			if (((oneGrid.x - twoGrid.x)== 0 && (oneGrid.y - twoGrid.y) == 1 ) ||                ((oneGrid.x - twoGrid.x)== 0 && (twoGrid.y - oneGrid.y) == 1 ) ||                ((oneGrid.x - twoGrid.x)== 1 && (oneGrid.y - twoGrid.y) == 0 ) ||                ((twoGrid.x - oneGrid.x)== 1 && (twoGrid.y - oneGrid.y) == 0 )                )            {                [self.delegate combinePiece:one.reference								  withOther:two.reference];                break;            }        }    }}-(void)dealloc{    [_gamePieces release];    _gamePieces = nil;//    [_otherPieces release];//    _otherPieces = nil;    [super dealloc];}@end